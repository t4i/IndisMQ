// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
#define FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_

#include "flatbuffers/flatbuffers.h"

namespace IndisMQ {

struct Ver;

struct Imq;
struct ImqT;

enum class MsgType : int8_t {
  NONE = 0,
  PEER = 1,
  MULT = 2,
  QUEUE = 3,
  CMD = 4,
  MIN = NONE,
  MAX = CMD
};

inline const char **EnumNamesMsgType() {
  static const char *names[] = { "NONE", "PEER", "MULT", "QUEUE", "CMD", nullptr };
  return names;
}

inline const char *EnumNameMsgType(MsgType e) { return EnumNamesMsgType()[static_cast<int>(e)]; }

enum class Cmd : int8_t {
  NONE = 0,
  SUB = 1,
  UNSUB = 2,
  SYN = 3,
  MIN = NONE,
  MAX = SYN
};

inline const char **EnumNamesCmd() {
  static const char *names[] = { "NONE", "SUB", "UNSUB", "SYN", nullptr };
  return names;
}

inline const char *EnumNameCmd(Cmd e) { return EnumNamesCmd()[static_cast<int>(e)]; }

enum class Sts : int8_t {
  NONE = 0,
  ERROR = 1,
  REQ = 2,
  REP = 3,
  CANCEL = 4,
  SUCCESS = 5,
  MIN = NONE,
  MAX = SUCCESS
};

inline const char **EnumNamesSts() {
  static const char *names[] = { "NONE", "ERROR", "REQ", "REP", "CANCEL", "SUCCESS", nullptr };
  return names;
}

inline const char *EnumNameSts(Sts e) { return EnumNamesSts()[static_cast<int>(e)]; }

enum class Err : int8_t {
  NONE = 0,
  NO_HANDLER = 1,
  INVALID = 2,
  REMOTE = 3,
  TIMEOUT = 4,
  MIN = NONE,
  MAX = TIMEOUT
};

inline const char **EnumNamesErr() {
  static const char *names[] = { "NONE", "NO_HANDLER", "INVALID", "REMOTE", "TIMEOUT", nullptr };
  return names;
}

inline const char *EnumNameErr(Err e) { return EnumNamesErr()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(1) Ver FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t Major_;
  int8_t Minor_;

 public:
  Ver() { memset(this, 0, sizeof(Ver)); }
  Ver(const Ver &_o) { memcpy(this, &_o, sizeof(Ver)); }
  Ver(int8_t _Major, int8_t _Minor)
    : Major_(flatbuffers::EndianScalar(_Major)), Minor_(flatbuffers::EndianScalar(_Minor)) { }

  int8_t Major() const { return flatbuffers::EndianScalar(Major_); }
  int8_t Minor() const { return flatbuffers::EndianScalar(Minor_); }
};
STRUCT_END(Ver, 2);

struct ImqT : public flatbuffers::NativeTable {
  std::vector<uint8_t> Body;
  std::string From;
  std::string To;
  bool Broker;
  Cmd Cmd;
  std::string MsgId;
  MsgType MsgType;
  Sts Sts;
  std::string Path;
  Err Err;
  std::string StsMsg;
  bool Callback;
  std::unique_ptr<Ver> Ver;
};

struct Imq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BODY = 4,
    VT_FROM = 6,
    VT_TO = 8,
    VT_BROKER = 10,
    VT_CMD = 12,
    VT_MSGID = 14,
    VT_MSGTYPE = 16,
    VT_STS = 18,
    VT_PATH = 20,
    VT_ERR = 22,
    VT_STSMSG = 24,
    VT_CALLBACK = 26,
    VT_VER = 28
  };
  const flatbuffers::Vector<uint8_t> *Body() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY); }
  const flatbuffers::String *From() const { return GetPointer<const flatbuffers::String *>(VT_FROM); }
  const flatbuffers::String *To() const { return GetPointer<const flatbuffers::String *>(VT_TO); }
  bool Broker() const { return GetField<uint8_t>(VT_BROKER, 0) != 0; }
  IndisMQ::Cmd Cmd() const { return static_cast<IndisMQ::Cmd>(GetField<int8_t>(VT_CMD, 0)); }
  const flatbuffers::String *MsgId() const { return GetPointer<const flatbuffers::String *>(VT_MSGID); }
  IndisMQ::MsgType MsgType() const { return static_cast<IndisMQ::MsgType>(GetField<int8_t>(VT_MSGTYPE, 0)); }
  IndisMQ::Sts Sts() const { return static_cast<IndisMQ::Sts>(GetField<int8_t>(VT_STS, 0)); }
  const flatbuffers::String *Path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  IndisMQ::Err Err() const { return static_cast<IndisMQ::Err>(GetField<int8_t>(VT_ERR, 0)); }
  const flatbuffers::String *StsMsg() const { return GetPointer<const flatbuffers::String *>(VT_STSMSG); }
  bool Callback() const { return GetField<uint8_t>(VT_CALLBACK, 0) != 0; }
  const IndisMQ::Ver *Ver() const { return GetStruct<const IndisMQ::Ver *>(VT_VER); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODY) &&
           verifier.Verify(Body()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FROM) &&
           verifier.Verify(From()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TO) &&
           verifier.Verify(To()) &&
           VerifyField<uint8_t>(verifier, VT_BROKER) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MSGID) &&
           verifier.Verify(MsgId()) &&
           VerifyField<int8_t>(verifier, VT_MSGTYPE) &&
           VerifyField<int8_t>(verifier, VT_STS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(Path()) &&
           VerifyField<int8_t>(verifier, VT_ERR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STSMSG) &&
           verifier.Verify(StsMsg()) &&
           VerifyField<uint8_t>(verifier, VT_CALLBACK) &&
           VerifyField<IndisMQ::Ver>(verifier, VT_VER) &&
           verifier.EndTable();
  }
  std::unique_ptr<ImqT> UnPack() const;
};

struct ImqBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body) { fbb_.AddOffset(Imq::VT_BODY, Body); }
  void add_From(flatbuffers::Offset<flatbuffers::String> From) { fbb_.AddOffset(Imq::VT_FROM, From); }
  void add_To(flatbuffers::Offset<flatbuffers::String> To) { fbb_.AddOffset(Imq::VT_TO, To); }
  void add_Broker(bool Broker) { fbb_.AddElement<uint8_t>(Imq::VT_BROKER, static_cast<uint8_t>(Broker), 0); }
  void add_Cmd(Cmd Cmd) { fbb_.AddElement<int8_t>(Imq::VT_CMD, static_cast<int8_t>(Cmd), 0); }
  void add_MsgId(flatbuffers::Offset<flatbuffers::String> MsgId) { fbb_.AddOffset(Imq::VT_MSGID, MsgId); }
  void add_MsgType(MsgType MsgType) { fbb_.AddElement<int8_t>(Imq::VT_MSGTYPE, static_cast<int8_t>(MsgType), 0); }
  void add_Sts(Sts Sts) { fbb_.AddElement<int8_t>(Imq::VT_STS, static_cast<int8_t>(Sts), 0); }
  void add_Path(flatbuffers::Offset<flatbuffers::String> Path) { fbb_.AddOffset(Imq::VT_PATH, Path); }
  void add_Err(Err Err) { fbb_.AddElement<int8_t>(Imq::VT_ERR, static_cast<int8_t>(Err), 0); }
  void add_StsMsg(flatbuffers::Offset<flatbuffers::String> StsMsg) { fbb_.AddOffset(Imq::VT_STSMSG, StsMsg); }
  void add_Callback(bool Callback) { fbb_.AddElement<uint8_t>(Imq::VT_CALLBACK, static_cast<uint8_t>(Callback), 0); }
  void add_Ver(const Ver *Ver) { fbb_.AddStruct(Imq::VT_VER, Ver); }
  ImqBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ImqBuilder &operator=(const ImqBuilder &);
  flatbuffers::Offset<Imq> Finish() {
    auto o = flatbuffers::Offset<Imq>(fbb_.EndTable(start_, 13));
    return o;
  }
};

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Body = 0,
    flatbuffers::Offset<flatbuffers::String> From = 0,
    flatbuffers::Offset<flatbuffers::String> To = 0,
    bool Broker = false,
    Cmd Cmd = Cmd::NONE,
    flatbuffers::Offset<flatbuffers::String> MsgId = 0,
    MsgType MsgType = MsgType::NONE,
    Sts Sts = Sts::NONE,
    flatbuffers::Offset<flatbuffers::String> Path = 0,
    Err Err = Err::NONE,
    flatbuffers::Offset<flatbuffers::String> StsMsg = 0,
    bool Callback = false,
    const Ver *Ver = 0) {
  ImqBuilder builder_(_fbb);
  builder_.add_Ver(Ver);
  builder_.add_StsMsg(StsMsg);
  builder_.add_Path(Path);
  builder_.add_MsgId(MsgId);
  builder_.add_To(To);
  builder_.add_From(From);
  builder_.add_Body(Body);
  builder_.add_Callback(Callback);
  builder_.add_Err(Err);
  builder_.add_Sts(Sts);
  builder_.add_MsgType(MsgType);
  builder_.add_Cmd(Cmd);
  builder_.add_Broker(Broker);
  return builder_.Finish();
}

inline flatbuffers::Offset<Imq> CreateImqDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *Body = nullptr,
    const char *From = nullptr,
    const char *To = nullptr,
    bool Broker = false,
    Cmd Cmd = Cmd::NONE,
    const char *MsgId = nullptr,
    MsgType MsgType = MsgType::NONE,
    Sts Sts = Sts::NONE,
    const char *Path = nullptr,
    Err Err = Err::NONE,
    const char *StsMsg = nullptr,
    bool Callback = false,
    const Ver *Ver = 0) {
  return CreateImq(_fbb, Body ? _fbb.CreateVector<uint8_t>(*Body) : 0, From ? _fbb.CreateString(From) : 0, To ? _fbb.CreateString(To) : 0, Broker, Cmd, MsgId ? _fbb.CreateString(MsgId) : 0, MsgType, Sts, Path ? _fbb.CreateString(Path) : 0, Err, StsMsg ? _fbb.CreateString(StsMsg) : 0, Callback, Ver);
}

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb, const ImqT *_o);

inline std::unique_ptr<ImqT> Imq::UnPack() const {
  auto _o = new ImqT();
  { auto _e = Body(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Body.push_back(_e->Get(_i)); } } };
  { auto _e = From(); if (_e) _o->From = _e->str(); };
  { auto _e = To(); if (_e) _o->To = _e->str(); };
  { auto _e = Broker(); _o->Broker = _e; };
  { auto _e = Cmd(); _o->Cmd = _e; };
  { auto _e = MsgId(); if (_e) _o->MsgId = _e->str(); };
  { auto _e = MsgType(); _o->MsgType = _e; };
  { auto _e = Sts(); _o->Sts = _e; };
  { auto _e = Path(); if (_e) _o->Path = _e->str(); };
  { auto _e = Err(); _o->Err = _e; };
  { auto _e = StsMsg(); if (_e) _o->StsMsg = _e->str(); };
  { auto _e = Callback(); _o->Callback = _e; };
  { auto _e = Ver(); if (_e) _o->Ver = std::unique_ptr<IndisMQ::Ver>(new IndisMQ::Ver(*_e)); };
  return std::unique_ptr<ImqT>(_o);
}

inline flatbuffers::Offset<Imq> CreateImq(flatbuffers::FlatBufferBuilder &_fbb, const ImqT *_o) {
  return CreateImq(_fbb,
    _o->Body.size() ? _fbb.CreateVector(_o->Body) : 0,
    _o->From.size() ? _fbb.CreateString(_o->From) : 0,
    _o->To.size() ? _fbb.CreateString(_o->To) : 0,
    _o->Broker,
    _o->Cmd,
    _o->MsgId.size() ? _fbb.CreateString(_o->MsgId) : 0,
    _o->MsgType,
    _o->Sts,
    _o->Path.size() ? _fbb.CreateString(_o->Path) : 0,
    _o->Err,
    _o->StsMsg.size() ? _fbb.CreateString(_o->StsMsg) : 0,
    _o->Callback,
    _o->Ver ? _o->Ver.get() : 0);
}

inline const IndisMQ::Imq *GetImq(const void *buf) { return flatbuffers::GetRoot<IndisMQ::Imq>(buf); }

inline const char *ImqIdentifier() { return "0001"; }

inline bool ImqBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, ImqIdentifier()); }

inline bool VerifyImqBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<IndisMQ::Imq>(ImqIdentifier()); }

inline void FinishImqBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<IndisMQ::Imq> root) { fbb.Finish(root, ImqIdentifier()); }

}  // namespace IndisMQ

#endif  // FLATBUFFERS_GENERATED_INDISMQ_INDISMQ_H_
